<!doctype html><html lang=zh><head><title>ioc和aop · j</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=description content="什么是IOC  Link to heading   IOC是Inversion of Control的缩写，多数书籍翻译成&#34;控制反转&#34;或者”依赖注入“。
IO理论观点大体是这样：借助于“第三方”实现具有依赖关系的对象之间的解耦，见上图。
为什么会起”控制反转“这个名字  Link to heading   软件系统在没有引入IOC容器之前，如图所示，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。
软件系统在引入IOC容器之后，这种情形就完全改变了，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。
通过前后的对比，我们不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。"><meta name=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="ioc和aop"><meta name=twitter:description content="什么是IOC  Link to heading   IOC是Inversion of Control的缩写，多数书籍翻译成&#34;控制反转&#34;或者”依赖注入“。
IO理论观点大体是这样：借助于“第三方”实现具有依赖关系的对象之间的解耦，见上图。
为什么会起”控制反转“这个名字  Link to heading   软件系统在没有引入IOC容器之前，如图所示，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。
软件系统在引入IOC容器之后，这种情形就完全改变了，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。
通过前后的对比，我们不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。"><meta property="og:title" content="ioc和aop"><meta property="og:description" content="什么是IOC  Link to heading   IOC是Inversion of Control的缩写，多数书籍翻译成&#34;控制反转&#34;或者”依赖注入“。
IO理论观点大体是这样：借助于“第三方”实现具有依赖关系的对象之间的解耦，见上图。
为什么会起”控制反转“这个名字  Link to heading   软件系统在没有引入IOC容器之前，如图所示，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。
软件系统在引入IOC容器之后，这种情形就完全改变了，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。
通过前后的对比，我们不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。"><meta property="og:type" content="article"><meta property="og:url" content="https://ramoncjj.github.io/posts/ioc/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-11-17T00:00:00+00:00"><meta property="article:modified_time" content="2022-11-17T00:00:00+00:00"><link rel=canonical href=https://ramoncjj.github.io/posts/ioc/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.c4d7e93a158eda5a65b3df343745d2092a0a1e2170feeec909b8a89443903c6a.css integrity="sha256-xNfpOhWO2lpls980N0XSCSoKHiFw/u7JCbiolEOQPGo=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.39e41a7f16bdf8cb16e43cae7d714fa1016f1d2d2898a5b3f27f42c9979204e2.css integrity="sha256-OeQafxa9+MsW5DyufXFPoQFvHS0omKWz8n9CyZeSBOI=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><meta name=generator content="Hugo 0.85.0"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>j</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>文章</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://ramoncjj.github.io/posts/ioc/>ioc和aop</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2022-11-17T00:00:00Z>2022 November 17</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i></span></div><div class=categories><i class="fa fa-folder" aria-hidden=true></i>
<a href=/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/>服务器</a></div></div></header><div><img src=/images/IOC.PNG alt="Featured image"><h2 id=什么是ioc>什么是IOC
<a class=heading-link href=#%e4%bb%80%e4%b9%88%e6%98%afioc><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>IOC是Inversion of Control的缩写，多数书籍翻译成"控制反转"或者”依赖注入“。</p><p>IO理论观点大体是这样：借助于“第三方”实现具有依赖关系的对象之间的解耦，见上图。</p><h2 id=为什么会起控制反转这个名字>为什么会起”控制反转“这个名字
<a class=heading-link href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bc%9a%e8%b5%b7%e6%8e%a7%e5%88%b6%e5%8f%8d%e8%bd%ac%e8%bf%99%e4%b8%aa%e5%90%8d%e5%ad%97><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>软件系统在没有引入IOC容器之前，如图所示，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。</p><p>软件系统在引入IOC容器之后，这种情形就完全改变了，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。</p><p>通过前后的对比，我们不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。</p></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2022
·
<a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.08fc7a7924db1ae6786408cb68e12ff953e6329376a469f5f517f3769c19194d.js integrity="sha256-CPx6eSTbGuZ4ZAjLaOEv+VPmMpN2pGn19RfzdpwZGU0="></script></body></html>