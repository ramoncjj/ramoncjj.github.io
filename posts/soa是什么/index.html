<!doctype html><html lang=zh><head><title>SOA通俗解释 · j</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=description content=" Link to heading   SOA  Link to heading   粗暴理解：把系统按照实际业务，拆分成刚刚好大小的、合适的、独立部署的模块，每个模块之间相互独立。
 比如现我有一个数据库，一个JavaWeb（或者PHP等）的网站客户端，一个安卓app客户端，一个IOS客户端。现在我要从这个数据库中获取注册用户列表，如果不用SOA的设计思想，那么就会这样：JavaWeb里面写一个查询方法从数据库里面查数据然后在网页显示，安卓app里面写一个查询方法查询后在app上显示，IOS同样如此。这里就会出现查询方法重叠了，这样的坏处很明显了，三个地方都有相同的业务代码，要改三个地方都要改，而且要改的一模一样。当然问题不止这一个。
 于是乎出现了这样的设计思想:
 比如用Java（或者是其他语言皆可）单独创建一个工程部署在一台服务器上，并且写一个方法（或称函数）执行上述查询操作，然后使其他人可以通过某种途径（可以是http链接，或者是基于socket的RPC调用）访问这个方法得到返回数据，返回的数据类型是通用的json或者xml数据，就是说把这个操作封装到一个工程中去，然后暴露访问的方式，形成“服务”。比如这里就是注册用户服务，而关于注册用户的所有相关增删改查操作这个服务都会提供方法。这样一来，JavaWeb这边可以访问这个服务然后得到数据使用，安卓和IOS这里也可以通过这个服务得到数据。而且最重要的是，要修改关于注册用户的业务方法只要改这个服务就好了，很好的解耦。同理，其他业务比如商品、广告等业务都可以单独形成服务部署在单独服务器上。还有就是一旦哪天突然有一堆人要注册，假设这堆人仅仅只是注册而不做其他事情，其他业务比如商品、广告服务等都不忙，唯独注册这个功能压力很大，而原有的一台部署了注册服务的服务器已经承受不了这么高的并发，这时候就可以单独集群部署这个注册服务，提供多几台服务器提供注册服务，而其他服务还不忙，那就维持原样。当然，还有很多其他好处。
 以上我所描述的就是基本的SOA思想了，按照业务功能将本来一整块的系统拆分为各个不同的子系统分别提供不同的服务，服务之间通过接口相互调用。这就是所谓的“面向服务的架构”。
后来又有了微服务的概念，个人理解微服务和SOA就是孪生子。如今生产实践中提到的微服务，在SOA的基础上更进一层，引入了很多新的东西如服务治理、链路跟踪、配置管理等等可以帮助企业构建高可用高并发高性能的系统的组件。什么是服务治理，就是当服务越来越多，调用方也越来越多的时候，它们之间的关系就变得非常混乱，需要对这些关系进行管理。举例，还是上面的例子:
 假如我有一个商家服务，一开始有购物车服务和订单服务来使用这个服务，后来越来越多其他服务需要调用该商品服务，将近上百个调用方，这个时候作为服务方，它只知道提供服务，却不知道具体为谁提供了服务，并且这个商家服务不但是服务提供者角色，它自己也是服务调用者，比如它可能需要调用商品服务、用户服务器等等。而对于开发者来说，知道这N多调用方和N多服务方之间的关系是非常重要的。以Java开发为例，现在最流行的微服务框架如：Dubbo、SpringCloud，都有服务治理的功能，这样就能清晰地看到服务被谁谁谁调用，谁谁谁调用了哪些服务，哪些服务是热点服务需要配置服务器集群。此外，通过一些负载均衡组件如SpringCloud的Ribbon，服务集群的负载均衡也帮你搞定了，调用的时候只要指名服务名称，请求时会帮你完成负载均衡把请求打到集群中某台较空闲的服务器上，也是服务治理可以完成的重要功能之一。当然，还可以更进一步，加上服务监控跟踪等等等等之类的。实际上SOA只是一种架构设计模式，而SOAP、REST、RPC就是为了实践这种设计模式而设计的数据通讯方式，其中SOAP通俗理解就是服务间通过http+xml的形式完成数据交换，REST就是http+json的形式，RPC是基于socket的形式。CXF框架就是典型的SOAP/REST框架，Dubbo就是典型的RPC框架，而SpringCloud就是遵守REST规范的微服务生态系统。
 "><meta name=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="SOA通俗解释"><meta name=twitter:description content=" Link to heading   SOA  Link to heading   粗暴理解：把系统按照实际业务，拆分成刚刚好大小的、合适的、独立部署的模块，每个模块之间相互独立。
 比如现我有一个数据库，一个JavaWeb（或者PHP等）的网站客户端，一个安卓app客户端，一个IOS客户端。现在我要从这个数据库中获取注册用户列表，如果不用SOA的设计思想，那么就会这样：JavaWeb里面写一个查询方法从数据库里面查数据然后在网页显示，安卓app里面写一个查询方法查询后在app上显示，IOS同样如此。这里就会出现查询方法重叠了，这样的坏处很明显了，三个地方都有相同的业务代码，要改三个地方都要改，而且要改的一模一样。当然问题不止这一个。
 于是乎出现了这样的设计思想:
 比如用Java（或者是其他语言皆可）单独创建一个工程部署在一台服务器上，并且写一个方法（或称函数）执行上述查询操作，然后使其他人可以通过某种途径（可以是http链接，或者是基于socket的RPC调用）访问这个方法得到返回数据，返回的数据类型是通用的json或者xml数据，就是说把这个操作封装到一个工程中去，然后暴露访问的方式，形成“服务”。比如这里就是注册用户服务，而关于注册用户的所有相关增删改查操作这个服务都会提供方法。这样一来，JavaWeb这边可以访问这个服务然后得到数据使用，安卓和IOS这里也可以通过这个服务得到数据。而且最重要的是，要修改关于注册用户的业务方法只要改这个服务就好了，很好的解耦。同理，其他业务比如商品、广告等业务都可以单独形成服务部署在单独服务器上。还有就是一旦哪天突然有一堆人要注册，假设这堆人仅仅只是注册而不做其他事情，其他业务比如商品、广告服务等都不忙，唯独注册这个功能压力很大，而原有的一台部署了注册服务的服务器已经承受不了这么高的并发，这时候就可以单独集群部署这个注册服务，提供多几台服务器提供注册服务，而其他服务还不忙，那就维持原样。当然，还有很多其他好处。
 以上我所描述的就是基本的SOA思想了，按照业务功能将本来一整块的系统拆分为各个不同的子系统分别提供不同的服务，服务之间通过接口相互调用。这就是所谓的“面向服务的架构”。
后来又有了微服务的概念，个人理解微服务和SOA就是孪生子。如今生产实践中提到的微服务，在SOA的基础上更进一层，引入了很多新的东西如服务治理、链路跟踪、配置管理等等可以帮助企业构建高可用高并发高性能的系统的组件。什么是服务治理，就是当服务越来越多，调用方也越来越多的时候，它们之间的关系就变得非常混乱，需要对这些关系进行管理。举例，还是上面的例子:
 假如我有一个商家服务，一开始有购物车服务和订单服务来使用这个服务，后来越来越多其他服务需要调用该商品服务，将近上百个调用方，这个时候作为服务方，它只知道提供服务，却不知道具体为谁提供了服务，并且这个商家服务不但是服务提供者角色，它自己也是服务调用者，比如它可能需要调用商品服务、用户服务器等等。而对于开发者来说，知道这N多调用方和N多服务方之间的关系是非常重要的。以Java开发为例，现在最流行的微服务框架如：Dubbo、SpringCloud，都有服务治理的功能，这样就能清晰地看到服务被谁谁谁调用，谁谁谁调用了哪些服务，哪些服务是热点服务需要配置服务器集群。此外，通过一些负载均衡组件如SpringCloud的Ribbon，服务集群的负载均衡也帮你搞定了，调用的时候只要指名服务名称，请求时会帮你完成负载均衡把请求打到集群中某台较空闲的服务器上，也是服务治理可以完成的重要功能之一。当然，还可以更进一步，加上服务监控跟踪等等等等之类的。实际上SOA只是一种架构设计模式，而SOAP、REST、RPC就是为了实践这种设计模式而设计的数据通讯方式，其中SOAP通俗理解就是服务间通过http+xml的形式完成数据交换，REST就是http+json的形式，RPC是基于socket的形式。CXF框架就是典型的SOAP/REST框架，Dubbo就是典型的RPC框架，而SpringCloud就是遵守REST规范的微服务生态系统。
 "><meta property="og:title" content="SOA通俗解释"><meta property="og:description" content=" Link to heading   SOA  Link to heading   粗暴理解：把系统按照实际业务，拆分成刚刚好大小的、合适的、独立部署的模块，每个模块之间相互独立。
 比如现我有一个数据库，一个JavaWeb（或者PHP等）的网站客户端，一个安卓app客户端，一个IOS客户端。现在我要从这个数据库中获取注册用户列表，如果不用SOA的设计思想，那么就会这样：JavaWeb里面写一个查询方法从数据库里面查数据然后在网页显示，安卓app里面写一个查询方法查询后在app上显示，IOS同样如此。这里就会出现查询方法重叠了，这样的坏处很明显了，三个地方都有相同的业务代码，要改三个地方都要改，而且要改的一模一样。当然问题不止这一个。
 于是乎出现了这样的设计思想:
 比如用Java（或者是其他语言皆可）单独创建一个工程部署在一台服务器上，并且写一个方法（或称函数）执行上述查询操作，然后使其他人可以通过某种途径（可以是http链接，或者是基于socket的RPC调用）访问这个方法得到返回数据，返回的数据类型是通用的json或者xml数据，就是说把这个操作封装到一个工程中去，然后暴露访问的方式，形成“服务”。比如这里就是注册用户服务，而关于注册用户的所有相关增删改查操作这个服务都会提供方法。这样一来，JavaWeb这边可以访问这个服务然后得到数据使用，安卓和IOS这里也可以通过这个服务得到数据。而且最重要的是，要修改关于注册用户的业务方法只要改这个服务就好了，很好的解耦。同理，其他业务比如商品、广告等业务都可以单独形成服务部署在单独服务器上。还有就是一旦哪天突然有一堆人要注册，假设这堆人仅仅只是注册而不做其他事情，其他业务比如商品、广告服务等都不忙，唯独注册这个功能压力很大，而原有的一台部署了注册服务的服务器已经承受不了这么高的并发，这时候就可以单独集群部署这个注册服务，提供多几台服务器提供注册服务，而其他服务还不忙，那就维持原样。当然，还有很多其他好处。
 以上我所描述的就是基本的SOA思想了，按照业务功能将本来一整块的系统拆分为各个不同的子系统分别提供不同的服务，服务之间通过接口相互调用。这就是所谓的“面向服务的架构”。
后来又有了微服务的概念，个人理解微服务和SOA就是孪生子。如今生产实践中提到的微服务，在SOA的基础上更进一层，引入了很多新的东西如服务治理、链路跟踪、配置管理等等可以帮助企业构建高可用高并发高性能的系统的组件。什么是服务治理，就是当服务越来越多，调用方也越来越多的时候，它们之间的关系就变得非常混乱，需要对这些关系进行管理。举例，还是上面的例子:
 假如我有一个商家服务，一开始有购物车服务和订单服务来使用这个服务，后来越来越多其他服务需要调用该商品服务，将近上百个调用方，这个时候作为服务方，它只知道提供服务，却不知道具体为谁提供了服务，并且这个商家服务不但是服务提供者角色，它自己也是服务调用者，比如它可能需要调用商品服务、用户服务器等等。而对于开发者来说，知道这N多调用方和N多服务方之间的关系是非常重要的。以Java开发为例，现在最流行的微服务框架如：Dubbo、SpringCloud，都有服务治理的功能，这样就能清晰地看到服务被谁谁谁调用，谁谁谁调用了哪些服务，哪些服务是热点服务需要配置服务器集群。此外，通过一些负载均衡组件如SpringCloud的Ribbon，服务集群的负载均衡也帮你搞定了，调用的时候只要指名服务名称，请求时会帮你完成负载均衡把请求打到集群中某台较空闲的服务器上，也是服务治理可以完成的重要功能之一。当然，还可以更进一步，加上服务监控跟踪等等等等之类的。实际上SOA只是一种架构设计模式，而SOAP、REST、RPC就是为了实践这种设计模式而设计的数据通讯方式，其中SOAP通俗理解就是服务间通过http+xml的形式完成数据交换，REST就是http+json的形式，RPC是基于socket的形式。CXF框架就是典型的SOAP/REST框架，Dubbo就是典型的RPC框架，而SpringCloud就是遵守REST规范的微服务生态系统。
 "><meta property="og:type" content="article"><meta property="og:url" content="https://ramoncjj.github.io/posts/soa%E6%98%AF%E4%BB%80%E4%B9%88/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-11-17T00:00:00+00:00"><meta property="article:modified_time" content="2022-11-17T00:00:00+00:00"><link rel=canonical href=https://ramoncjj.github.io/posts/soa%E6%98%AF%E4%BB%80%E4%B9%88/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.c4d7e93a158eda5a65b3df343745d2092a0a1e2170feeec909b8a89443903c6a.css integrity="sha256-xNfpOhWO2lpls980N0XSCSoKHiFw/u7JCbiolEOQPGo=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.39e41a7f16bdf8cb16e43cae7d714fa1016f1d2d2898a5b3f27f42c9979204e2.css integrity="sha256-OeQafxa9+MsW5DyufXFPoQFvHS0omKWz8n9CyZeSBOI=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><meta name=generator content="Hugo 0.85.0"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>j</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>文章</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://ramoncjj.github.io/posts/soa%E6%98%AF%E4%BB%80%E4%B9%88/>SOA通俗解释</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2022-11-17T00:00:00Z>2022 November 17</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i></span></div><div class=categories><i class="fa fa-folder" aria-hidden=true></i>
<a href=/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/>服务器</a></div></div></header><div><img src=/images/%e4%bb%80%e4%b9%88%e6%98%af%e6%9c%8d%e5%8a%a1%e5%99%a8.PNG alt="Featured image"><h2 id=heading><a class=heading-link href=#heading><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><h2 id=soa>SOA
<a class=heading-link href=#soa><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>粗暴理解：把系统按照实际业务，拆分成刚刚好大小的、合适的、独立部署的模块，每个模块之间相互独立。</p><blockquote><p>比如现我有一个数据库，一个JavaWeb（或者PHP等）的网站客户端，一个安卓app客户端，一个IOS客户端。现在我要从这个数据库中获取注册用户列表，如果不用SOA的设计思想，那么就会这样：JavaWeb里面写一个查询方法从数据库里面查数据然后在网页显示，安卓app里面写一个查询方法查询后在app上显示，IOS同样如此。这里就会出现查询方法重叠了，这样的坏处很明显了，三个地方都有相同的业务代码，要改三个地方都要改，而且要改的一模一样。当然问题不止这一个。</p></blockquote><p>于是乎出现了这样的设计思想:</p><blockquote><p>比如用Java（或者是其他语言皆可）单独创建一个工程部署在一台服务器上，并且写一个方法（或称函数）执行上述查询操作，然后使其他人可以通过某种途径（可以是http链接，或者是基于socket的RPC调用）访问这个方法得到返回数据，返回的数据类型是通用的json或者xml数据，就是说把这个操作封装到一个工程中去，然后暴露访问的方式，形成“服务”。比如这里就是注册用户服务，而关于注册用户的所有相关增删改查操作这个服务都会提供方法。这样一来，JavaWeb这边可以访问这个服务然后得到数据使用，安卓和IOS这里也可以通过这个服务得到数据。而且最重要的是，要修改关于注册用户的业务方法只要改这个服务就好了，很好的解耦。同理，其他业务比如商品、广告等业务都可以单独形成服务部署在单独服务器上。还有就是一旦哪天突然有一堆人要注册，假设这堆人仅仅只是注册而不做其他事情，其他业务比如商品、广告服务等都不忙，唯独注册这个功能压力很大，而原有的一台部署了注册服务的服务器已经承受不了这么高的并发，这时候就可以单独集群部署这个注册服务，提供多几台服务器提供注册服务，而其他服务还不忙，那就维持原样。当然，还有很多其他好处。</p></blockquote><p>以上我所描述的就是基本的SOA思想了，按照业务功能将本来一整块的系统拆分为各个不同的子系统分别提供不同的服务，服务之间通过接口相互调用。这就是所谓的“面向服务的架构”。</p><p>后来又有了微服务的概念，个人理解微服务和SOA就是孪生子。如今生产实践中提到的微服务，在SOA的基础上更进一层，引入了很多新的东西如服务治理、链路跟踪、配置管理等等可以帮助企业构建高可用高并发高性能的系统的组件。什么是服务治理，就是当服务越来越多，调用方也越来越多的时候，它们之间的关系就变得非常混乱，需要对这些关系进行管理。举例，还是上面的例子:</p><blockquote><p>假如我有一个商家服务，一开始有购物车服务和订单服务来使用这个服务，后来越来越多其他服务需要调用该商品服务，将近上百个调用方，这个时候作为服务方，它只知道提供服务，却不知道具体为谁提供了服务，并且这个商家服务不但是服务提供者角色，它自己也是服务调用者，比如它可能需要调用商品服务、用户服务器等等。而对于开发者来说，知道这N多调用方和N多服务方之间的关系是非常重要的。以Java开发为例，现在最流行的微服务框架如：Dubbo、SpringCloud，都有服务治理的功能，这样就能清晰地看到服务被谁谁谁调用，谁谁谁调用了哪些服务，哪些服务是热点服务需要配置服务器集群。此外，通过一些负载均衡组件如SpringCloud的Ribbon，服务集群的负载均衡也帮你搞定了，调用的时候只要指名服务名称，请求时会帮你完成负载均衡把请求打到集群中某台较空闲的服务器上，也是服务治理可以完成的重要功能之一。当然，还可以更进一步，加上服务监控跟踪等等等等之类的。实际上SOA只是一种架构设计模式，而SOAP、REST、RPC就是为了实践这种设计模式而设计的数据通讯方式，其中SOAP通俗理解就是服务间通过http+xml的形式完成数据交换，REST就是http+json的形式，RPC是基于socket的形式。CXF框架就是典型的SOAP/REST框架，Dubbo就是典型的RPC框架，而SpringCloud就是遵守REST规范的微服务生态系统。</p></blockquote></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2022
·
<a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.08fc7a7924db1ae6786408cb68e12ff953e6329376a469f5f517f3769c19194d.js integrity="sha256-CPx6eSTbGuZ4ZAjLaOEv+VPmMpN2pGn19RfzdpwZGU0="></script></body></html>